{
  "tasks": [
    {
      "id": 1,
      "title": "[MVP] 프로젝트 인프라 및 인증 구축",
      "description": "React 프로젝트 초기화, Supabase 통합 구성 및 사용자 인증 흐름 구현",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create React App 또는 Vite를 사용하여 새 React 프로젝트를 생성합니다. 데이터베이스, 인증 및 스토리지를 위한 Supabase 클라이언트 구성을 설정합니다. Supabase Auth를 사용하여 이메일/비밀번호 인증으로 회원가입/로그인 컴포넌트를 구현합니다. 인증된 사용자를 위한 보호된 경로와 온보딩을 위한 공개 경로를 만듭니다. Vercel 또는 Netlify를 사용하여 자동 배포를 위한 CI/CD 파이프라인을 설정합니다.",
      "testStrategy": "사용자 등록, 로그인 및 로그아웃 기능을 확인합니다. 보호된 경로가 인증되지 않은 사용자를 리디렉션하는지 테스트합니다. 인증 흐름에 대한 양식 유효성 검사 및 오류 처리를 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "React 프로젝트 초기화 및 기본 구조 설정",
          "description": "Vite를 사용하여 React 프로젝트를 초기화하고 필요한 기본 폴더 구조와 라이브러리를 설정합니다.",
          "dependencies": [],
          "details": "1. Vite를 사용하여 React 프로젝트 생성: `npm create vite@latest my-app --template react-ts`\n2. 필요한 기본 라이브러리 설치: `npm install react-router-dom axios styled-components`\n3. 프로젝트 폴더 구조 설정:\n   - `/src/components`: 재사용 가능한 UI 컴포넌트\n   - `/src/pages`: 페이지 컴포넌트\n   - `/src/hooks`: 커스텀 훅\n   - `/src/utils`: 유틸리티 함수\n   - `/src/services`: API 서비스\n   - `/src/contexts`: React Context\n4. 기본 라우팅 설정: React Router를 사용하여 기본 라우팅 구조 구현\n5. 테스트: `npm run dev`로 프로젝트가 정상적으로 실행되는지 확인",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 2,
          "title": "Supabase 프로젝트 생성 및 클라이언트 설정",
          "description": "Supabase 프로젝트를 생성하고 React 애플리케이션에 Supabase 클라이언트를 설정합니다.",
          "dependencies": [
            1
          ],
          "details": "1. Supabase 계정 생성 및 새 프로젝트 설정\n2. Supabase 클라이언트 라이브러리 설치: `npm install @supabase/supabase-js`\n3. 환경 변수 설정:\n   - `.env` 파일 생성\n   - `VITE_SUPABASE_URL`과 `VITE_SUPABASE_ANON_KEY` 환경 변수 추가\n4. Supabase 클라이언트 초기화 파일 생성 (`/src/services/supabase.ts`):\n   ```typescript\n   import { createClient } from '@supabase/supabase-js';\n   \n   const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;\n   const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;\n   \n   export const supabase = createClient(supabaseUrl, supabaseAnonKey);\n   ```\n5. 테스트: 간단한 쿼리를 실행하여 Supabase 연결 확인",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 3,
          "title": "인증 컴포넌트 및 인증 상태 관리 구현",
          "description": "회원가입, 로그인, 로그아웃 컴포넌트를 구현하고 인증 상태를 관리하는 Context를 생성합니다.",
          "dependencies": [
            2
          ],
          "details": "1. 인증 Context 생성 (`/src/contexts/AuthContext.tsx`):\n   - 현재 사용자 상태 관리\n   - 로그인, 로그아웃, 회원가입 함수 제공\n   - 인증 상태 로딩 처리\n2. 회원가입 컴포넌트 구현 (`/src/components/auth/SignUp.tsx`):\n   - 이메일, 비밀번호 입력 폼\n   - Supabase Auth API를 사용한 회원가입 기능\n   - 오류 처리 및 유효성 검사\n3. 로그인 컴포넌트 구현 (`/src/components/auth/SignIn.tsx`):\n   - 이메일, 비밀번호 입력 폼\n   - Supabase Auth API를 사용한 로그인 기능\n   - 오류 처리\n4. 로그아웃 기능 구현\n5. 테스트: 회원가입, 로그인, 로그아웃 기능이 정상적으로 작동하는지 확인",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 4,
          "title": "보호된 라우트 및 인증 흐름 구현",
          "description": "인증된 사용자만 접근할 수 있는 보호된 라우트와 인증 흐름을 구현합니다.",
          "dependencies": [
            3
          ],
          "details": "1. 보호된 라우트 컴포넌트 생성 (`/src/components/auth/ProtectedRoute.tsx`):\n   - 인증되지 않은 사용자를 로그인 페이지로 리디렉션\n   - 인증 상태 로딩 중 로딩 UI 표시\n2. 공개 라우트 설정:\n   - 로그인 페이지\n   - 회원가입 페이지\n   - 랜딩 페이지\n3. 보호된 라우트 설정:\n   - 대시보드\n   - 프로필 페이지\n   - 설정 페이지\n4. 인증 상태에 따른 네비게이션 UI 조정\n5. 세션 유지 기능 구현:\n   - 페이지 새로고침 시 인증 상태 유지\n   - 세션 만료 처리\n6. 테스트: 인증되지 않은 사용자가 보호된 라우트에 접근할 수 없는지 확인",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 5,
          "title": "CI/CD 파이프라인 및 배포 환경 설정",
          "description": "Vercel 또는 Netlify를 사용하여 자동 배포를 위한 CI/CD 파이프라인을 설정합니다.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. 프로젝트 GitHub 저장소 설정:\n   - 새 GitHub 저장소 생성\n   - 프로젝트 코드 푸시\n   - `.gitignore` 파일에 환경 변수 파일 추가\n2. Vercel 계정 생성 및 프로젝트 설정:\n   - GitHub 저장소 연결\n   - 환경 변수 설정 (Supabase URL 및 API 키)\n   - 빌드 설정 구성\n3. 자동 배포 설정:\n   - main 브랜치에 푸시 시 자동 배포 설정\n   - 풀 리퀘스트에 대한 프리뷰 배포 설정\n4. 커스텀 도메인 설정 (선택 사항)\n5. 테스트: 코드 변경 사항을 푸시하여 자동 배포가 정상적으로 작동하는지 확인",
          "status": "done",
          "parentTaskId": 1
        }
      ]
    },
    {
      "id": 2,
      "title": "[MVP] 온보딩 및 꿈 입력 흐름 구현",
      "description": "신규 사용자를 위한 온보딩 경험 및 꿈 입력 인터페이스 생성",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "앱 기능을 소개하는 다단계 온보딩 프로세스를 설계하고 구현합니다. 사용자가 제목, 설명 및 선택적 태그로 꿈을 입력할 수 있는 양식을 만듭니다. 데이터 모델 사양에 따라 사용자 및 꿈 모델에 대한 Supabase 테이블을 설정합니다. 적절한 유효성 검사가 포함된 꿈 저장 기능을 구현합니다. 첫 사용자를 위한 환영 화면 및 안내를 추가합니다.",
      "testStrategy": "다양한 입력 시나리오로 전체 온보딩 흐름을 테스트합니다. 꿈 데이터가 Supabase에 올바르게 저장되는지 확인합니다. 필수 필드에 대한 유효성 검사 및 오류 처리를 확인합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "앱뷰 공통 레이아웃(AppShell) 및 하단 탭바 설계/구현",
          "description": "퍼플/그라데이션 테마, 카드형 UI, 하단 탭바 등 모바일 앱 스타일의 공통 레이아웃과 네비게이션 컴포넌트 설계 및 구현. Tailwind CSS 기반으로 max-w, 중앙정렬, 반응형, 카드/탭바/상단바 등 앱뷰 구조를 만든다. 홈(피드) 페이지에 적용해 PC/모바일 모두 네이티브앱처럼 보이도록 한다.",
          "details": "1. Tailwind CSS 테마 및 글로벌 스타일 세팅\n2. /src/components/layout/AppShell.tsx 생성 및 앱뷰 레이아웃 구현\n3. /src/components/layout/BottomTabBar.tsx 생성 및 하단 탭바 구현\n4. 카드형 UI, 버튼, 태그 등 공통 컴포넌트 설계\n5. 홈(피드) 페이지에 앱뷰 스타일 적용\n6. max-w-[430px] mx-auto min-h-screen 등 Tailwind 유틸리티 활용\n7. 모바일/PC 반응형 및 PWA 지원 구조 설계\n8. 테스트: PC/모바일에서 앱뷰가 일관되게 보이는지 확인",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 2
        }
      ]
    },
    {
      "id": 3,
      "title": "[MVP] AI 기반 목표 제안 시스템 개발",
      "description": "사용자 꿈을 기반으로 개인화된 목표를 생성하기 위한 Perplexity API 통합",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Perplexity API 통합을 설정합니다. 사용자 꿈 데이터를 처리하고 적절한 목표를 생성하는 서비스를 만듭니다. Supabase에서 목표 데이터 모델을 구현하고 dreamId로 꿈과 연결합니다. 품질 목표 제안을 보장하기 위한 AI 프롬프트 엔지니어링을 설계합니다. 사용자가 제안된 목표를 편집, 우선순위 지정 또는 거부할 수 있는 옵션이 있는 UI를 구축합니다.",
      "testStrategy": "샘플 꿈 입력으로 API 통합을 테스트합니다. 목표 생성 품질 및 관련성을 확인합니다. 최소한의 또는 비정상적인 꿈 설명이 있는 엣지 케이스를 테스트합니다. 데이터베이스에서 목표 저장 및 검색을 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "Perplexity API 연동 및 기본 통신 설정",
          "description": "AI 서비스와의 통신을 위한 기본 인프라 구축 및 API 연동 설정",
          "dependencies": [],
          "details": "1. Perplexity API 키 발급 및 환경 변수 설정\n2. API 클라이언트 래퍼 클래스 구현 (요청 전송, 응답 처리, 오류 처리)\n3. API 호출 제한 및 비용 관리를 위한 레이트 리미팅 구현\n4. 기본 프롬프트 템플릿 구조 설계\n5. 간단한 테스트 엔드포인트 구현으로 API 연결 확인\n6. 테스트: 기본 프롬프트로 API 응답 확인 및 응답 형식 검증",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 2,
          "title": "Supabase 꿈과 목표 데이터 모델 설계 및 구현",
          "description": "사용자 꿈과 생성된 목표를 저장하기 위한 데이터베이스 스키마 설계 및 구현",
          "dependencies": [],
          "details": "1. 사용자, 꿈, 목표 간의 관계를 정의하는 ERD 설계\n2. Supabase에 필요한 테이블 생성 (users, dreams, goals)\n3. Dream 테이블에 deadline 필드 추가\n4. Goal 테이블에 dreamId 외래 키 필드 추가하여 꿈과 목표 연결\n5. 목표 상태 관리를 위한 필드 추가 (제안됨, 수락됨, 거부됨, 완료됨 등)\n6. 필요한 인덱스 및 외래 키 제약 조건 설정\n7. TypeScript 인터페이스/타입 정의\n8. 테스트: CRUD 작업을 통한 데이터 모델 검증\n\n<info added on 2025-05-03T07:57:11.853Z>\n## Supabase 데이터 모델 구현 상세 정보\n\n### 1. 보안 정책(RLS) 설정\n```sql\n-- dreams 테이블 RLS\nalter table dreams enable row level security;\ncreate policy \"사용자는 자신의 꿈만 볼 수 있음\" on dreams\n  for select using (auth.uid() = user_id);\ncreate policy \"사용자는 자신의 꿈만 생성할 수 있음\" on dreams\n  for insert with check (auth.uid() = user_id);\ncreate policy \"사용자는 자신의 꿈만 수정할 수 있음\" on dreams\n  for update using (auth.uid() = user_id);\ncreate policy \"사용자는 자신의 꿈만 삭제할 수 있음\" on dreams\n  for delete using (auth.uid() = user_id);\n\n-- goals 테이블 RLS\nalter table goals enable row level security;\ncreate policy \"사용자는 자신의 꿈에 연결된 목표만 접근 가능\" on goals\n  for all using (auth.uid() = (select user_id from dreams where id = goals.dream_id));\n```\n\n### 2. 인덱스 설정\n```sql\n-- 성능 최적화를 위한 인덱스\ncreate index dreams_user_id_idx on dreams(user_id);\ncreate index goals_dream_id_idx on goals(dream_id);\ncreate index goals_status_idx on goals(status);\n```\n\n### 3. 목표 상태 관리를 위한 ENUM 타입\n```sql\ncreate type goal_status as enum ('proposed', 'accepted', 'rejected', 'completed', 'in_progress');\n-- goals 테이블의 status 필드 타입 변경\nalter table goals alter column status type goal_status using status::goal_status;\n```\n\n### 4. 트리거 함수 구현 (updated_at 자동 갱신)\n```sql\ncreate or replace function update_modified_column()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\ncreate trigger update_dreams_modtime\nbefore update on dreams\nfor each row execute function update_modified_column();\n\ncreate trigger update_goals_modtime\nbefore update on goals\nfor each row execute function update_modified_column();\n```\n\n### 5. 데이터 검증 함수 예시\n```typescript\n// src/utils/validation.ts\nexport const validateDream = (dream: Partial<Dream>): boolean => {\n  if (!dream.title || dream.title.trim().length < 3) return false;\n  if (dream.deadline && new Date(dream.deadline) < new Date()) return false;\n  return true;\n};\n\nexport const validateGoal = (goal: Partial<Goal>): boolean => {\n  if (!goal.title || goal.title.trim().length < 3) return false;\n  if (!goal.dream_id) return false;\n  return true;\n};\n```\n\n### 6. 테스트 쿼리 예시\n```sql\n-- 특정 사용자의 모든 꿈과 관련 목표 조회\nselect d.*, \n  (select json_agg(g.*) from goals g where g.dream_id = d.id) as goals\nfrom dreams d\nwhere d.user_id = '[USER_ID]';\n\n-- 상태별 목표 통계\nselect d.title as dream_title, \n  count(g.id) filter (where g.status = 'proposed') as proposed_goals,\n  count(g.id) filter (where g.status = 'accepted') as accepted_goals,\n  count(g.id) filter (where g.status = 'completed') as completed_goals\nfrom dreams d\nleft join goals g on d.id = g.dream_id\nwhere d.user_id = '[USER_ID]'\ngroup by d.id;\n```\n</info added on 2025-05-03T07:57:11.853Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 3,
          "title": "AI 프롬프트 엔지니어링 및 목표 생성 로직 개발",
          "description": "사용자 꿈 데이터를 분석하고 적절한 목표를 생성하기 위한 AI 프롬프트 설계",
          "dependencies": [
            1,
            2
          ],
          "details": "1. 효과적인 목표 생성을 위한 프롬프트 템플릿 설계\n2. 꿈 데이터에서 핵심 주제와 패턴을 추출하는 프롬프트 개발\n3. SMART 목표 원칙(구체적, 측정 가능, 달성 가능, 관련성, 시간 제한)을 적용한 프롬프트 구성\n4. 목표 품질 향상을 위한 프롬프트 반복 테스트 및 개선\n5. 응답 파싱 및 구조화 로직 구현\n6. 테스트: 다양한 꿈 시나리오에 대한 목표 생성 품질 평가",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 4,
          "title": "꿈 데이터 처리 및 목표 생성 서비스 구현",
          "description": "사용자 꿈 데이터를 수집하고 AI를 통해 목표로 변환하는 서비스 개발",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. 꿈 데이터 입력 및 처리를 위한 서비스 레이어 구현\n2. 꿈 데이터를 AI 프롬프트에 통합하는 로직 개발\n3. AI 응답에서 목표 데이터 추출 및 구조화\n4. 생성된 목표를 Supabase에 저장하고 dreamId로 연결하는 기능 구현\n5. 목표 중복 방지 및 품질 검증 로직 추가\n6. 비동기 처리를 위한 작업 큐 구현 (선택적)\n7. 테스트: 전체 파이프라인 통합 테스트 (꿈 입력부터 목표 저장까지)\n\n<info added on 2025-05-03T08:19:58.595Z>\n## AI 목표 생성 및 저장 로직 구현 세부사항\n\n### 데이터 흐름 구조\n- `DreamInput` 컴포넌트에서 꿈 저장 후 반환된 `dream_id`를 활용하여 목표 연결\n- AI 응답 파싱 시 정규식 패턴 활용: `/^[\\d\\s\\-\\•\\*]+|^\\s*$/gm`으로 숫자/대시/빈줄 제거\n\n### 목표 품질 검증 로직\n- 최소 길이(10자) 및 최대 길이(100자) 검증\n- 중복 목표 필터링 (Levenshtein 거리 알고리즘 활용, 유사도 80% 이상 제외)\n- 부적절한 내용 필터링 (금지어 목록 활용)\n\n### 오류 처리 메커니즘\n- AI 응답 실패 시 재시도 로직 (최대 3회)\n- 목표 저장 실패 시 트랜잭션 롤백 구현\n- 사용자에게 진행 상태 표시 (로딩 인디케이터 및 단계별 피드백)\n\n### 성능 최적화\n- 목표 일괄 저장 시 Supabase `.insert()` 배치 처리 활용\n- 비동기 처리를 위한 Promise.all 패턴 적용\n- 대용량 응답 처리를 위한 청크 분할 메커니즘\n\n### 테스트 케이스\n- 다양한 꿈 입력에 대한 AI 응답 일관성 검증\n- 에러 상황 시뮬레이션 및 복구 테스트\n- 목표 품질 검증 로직 유닛 테스트\n</info added on 2025-05-03T08:19:58.595Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 5,
          "title": "목표 관리 API 엔드포인트 개발",
          "description": "목표 조회, 편집, 우선순위 지정, 거부 등을 위한 RESTful API 개발",
          "dependencies": [
            2,
            4
          ],
          "details": "1. 모든 목표 조회 엔드포인트 구현\n2. 꿈별 목표 조회 엔드포인트 구현 (dreamId 기준 필터링)\n3. 목표 상세 조회 엔드포인트 구현\n4. 목표 수정 엔드포인트 구현 (사용자 편집 지원)\n5. 목표 상태 변경 엔드포인트 구현 (수락, 거부, 완료 등)\n6. 목표 우선순위 지정 엔드포인트 구현\n7. 목표 삭제 엔드포인트 구현\n8. API 인증 및 권한 검사 로직 추가\n9. 테스트: Postman/Insomnia를 사용한 API 엔드포인트 테스트",
          "status": "pending",
          "parentTaskId": 3
        },
        {
          "id": 6,
          "title": "목표 제안 및 관리 UI 구현",
          "description": "사용자가 제안된 목표를 확인하고 관리할 수 있는 사용자 인터페이스 개발",
          "dependencies": [
            5
          ],
          "details": "1. 꿈 상세 페이지에서 해당 꿈의 목표 목록 UI 구현\n2. 목표 카드 컴포넌트 개발 (목표 내용, 상태, 우선순위 표시)\n3. 목표 편집 모달/페이지 구현\n4. 목표 수락/거부/완료 기능 UI 구현\n5. 목표 우선순위 드래그 앤 드롭 기능 구현\n6. 새로운 목표 제안 요청 UI 구현\n7. 반응형 디자인 적용 (모바일/데스크톱)\n8. 테스트: 사용자 시나리오 기반 UI 테스트 및 사용성 평가\n\n<info added on 2025-05-03T08:40:36.181Z>\n## 추가 구현 상세\n\n### UI 컴포넌트 구조화\n- `GoalFeedbackControls.tsx`: 목표 품질 피드백 컴포넌트 (좋아요/싫어요, 재생성 버튼)\n- `GoalStatusIndicator.tsx`: 목표 상태 표시 컴포넌트 (대기중, 수락됨, 거부됨, 완료됨)\n- `GoalPrioritySelector.tsx`: 우선순위 선택/표시 컴포넌트\n\n### 피드백 시스템 구현\n```typescript\n// GoalFeedbackControls.tsx\nconst GoalFeedbackControls: React.FC<{\n  goalId: string;\n  onLike: () => void;\n  onDislike: () => void;\n  onRegenerate: () => void;\n}> = ({ goalId, onLike, onDislike, onRegenerate }) => {\n  return (\n    <div className=\"goal-feedback-controls\">\n      <IconButton onClick={onLike} aria-label=\"좋아요\">\n        <ThumbUpIcon />\n      </IconButton>\n      <IconButton onClick={onDislike} aria-label=\"싫어요\">\n        <ThumbDownIcon />\n      </IconButton>\n      <Button \n        startIcon={<RefreshIcon />} \n        onClick={onRegenerate}\n        size=\"small\"\n      >\n        재생성\n      </Button>\n    </div>\n  );\n};\n```\n\n### 상태 관리 개선\n- 목표 생성/피드백/상태변경 과정의 상태 관리를 위한 커스텀 훅:\n```typescript\n// useGoalManagement.ts\nexport const useGoalManagement = (dreamId: string) => {\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [feedbackStatus, setFeedbackStatus] = useState<Record<string, 'liked' | 'disliked' | null>>({});\n  \n  const handleGoalFeedback = async (goalId: string, type: 'like' | 'dislike') => {\n    try {\n      await api.goals.provideFeedback(goalId, type);\n      setFeedbackStatus(prev => ({ ...prev, [goalId]: type === 'like' ? 'liked' : 'disliked' }));\n    } catch (error) {\n      console.error('Goal feedback failed:', error);\n    }\n  };\n  \n  // 추가 메서드들...\n  \n  return {\n    isGenerating,\n    feedbackStatus,\n    handleGoalFeedback,\n    // 기타 반환값...\n  };\n};\n```\n\n### 드래그 앤 드롭 우선순위 구현\n- react-beautiful-dnd 라이브러리 활용:\n```typescript\n// GoalPriorityList.tsx\nimport { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';\n\nconst GoalPriorityList: React.FC<{ goals: Goal[], onPriorityChange: (reorderedGoals: Goal[]) => void }> = \n  ({ goals, onPriorityChange }) => {\n  \n  const handleDragEnd = (result) => {\n    if (!result.destination) return;\n    \n    const items = Array.from(goals);\n    const [reorderedItem] = items.splice(result.source.index, 1);\n    items.splice(result.destination.index, 0, reorderedItem);\n    \n    onPriorityChange(items);\n  };\n  \n  return (\n    <DragDropContext onDragEnd={handleDragEnd}>\n      <Droppable droppableId=\"goals\">\n        {(provided) => (\n          <div {...provided.droppableProps} ref={provided.innerRef}>\n            {goals.map((goal, index) => (\n              <Draggable key={goal.id} draggableId={goal.id} index={index}>\n                {(provided) => (\n                  <div\n                    ref={provided.innerRef}\n                    {...provided.draggableProps}\n                    {...provided.dragHandleProps}\n                  >\n                    <GoalCard goal={goal} />\n                  </div>\n                )}\n              </Draggable>\n            ))}\n            {provided.placeholder}\n          </div>\n        )}\n      </Droppable>\n    </DragDropContext>\n  );\n};\n```\n\n### 테스트 시나리오 구체화\n1. 목표 생성 → 피드백 → 재생성 → 저장 흐름\n2. 목표 우선순위 변경 → 서버 저장 → 새로고침 후 유지 확인\n3. 모바일/태블릿/데스크톱 반응형 레이아웃 검증\n4. 목표 상태 변경 시 시각적 피드백 및 애니메이션 검증\n\n### 성능 최적화\n- 목표 목록 렌더링 최적화를 위한 가상화(virtualization) 고려\n- 상태 변경 시 불필요한 리렌더링 방지를 위한 메모이제이션 적용\n</info added on 2025-05-03T08:40:36.181Z>\n\n<info added on 2025-05-03T08:42:12.835Z>\n<info added on 2025-05-15T14:22:18.000Z>\n## DreamInput 목표 피드백 UI 구현 상세\n\n### 피드백 컴포넌트 구현\n```typescript\n// GoalFeedbackBar.tsx\nconst GoalFeedbackBar: React.FC<{\n  goalId: string;\n  onLike: (goalId: string) => Promise<void>;\n  onDislike: (goalId: string) => Promise<void>;\n  onRegenerate: () => Promise<void>;\n  isRegenerating: boolean;\n}> = ({ goalId, onLike, onDislike, onRegenerate, isRegenerating }) => {\n  const [feedbackGiven, setFeedbackGiven] = useState<'like' | 'dislike' | null>(null);\n  \n  const handleLike = async () => {\n    if (!feedbackGiven) {\n      await onLike(goalId);\n      setFeedbackGiven('like');\n      toast.success('피드백 감사합니다!');\n    }\n  };\n  \n  const handleDislike = async () => {\n    if (!feedbackGiven) {\n      await onDislike(goalId);\n      setFeedbackGiven('dislike');\n      toast.info('더 나은 목표를 제안해 드리겠습니다');\n    }\n  };\n  \n  return (\n    <div className=\"flex items-center space-x-2 mt-2\">\n      <button \n        onClick={handleLike}\n        className={`p-1 rounded-full ${feedbackGiven === 'like' ? 'bg-green-100 text-green-600' : 'hover:bg-gray-100'}`}\n        disabled={!!feedbackGiven}\n        aria-label=\"좋아요\"\n      >\n        <ThumbUpIcon className=\"h-5 w-5\" />\n      </button>\n      \n      <button \n        onClick={handleDislike}\n        className={`p-1 rounded-full ${feedbackGiven === 'dislike' ? 'bg-red-100 text-red-600' : 'hover:bg-gray-100'}`}\n        disabled={!!feedbackGiven}\n        aria-label=\"싫어요\"\n      >\n        <ThumbDownIcon className=\"h-5 w-5\" />\n      </button>\n      \n      <button\n        onClick={onRegenerate}\n        disabled={isRegenerating}\n        className=\"ml-auto flex items-center text-sm text-blue-600 hover:text-blue-800\"\n        aria-label=\"목표 재생성\"\n      >\n        {isRegenerating ? (\n          <SpinnerIcon className=\"animate-spin h-4 w-4 mr-1\" />\n        ) : (\n          <RefreshIcon className=\"h-4 w-4 mr-1\" />\n        )}\n        재생성\n      </button>\n    </div>\n  );\n};\n```\n\n### DreamInput 통합 구현\n```typescript\n// DreamInput.tsx (관련 부분)\nconst DreamInput: React.FC = () => {\n  // ... 기존 상태 관리 코드 ...\n  const [isRegenerating, setIsRegenerating] = useState<Record<string, boolean>>({});\n  const [feedbackStats, setFeedbackStats] = useState<{\n    likes: number;\n    dislikes: number;\n    regenerations: number;\n  }>({ likes: 0, dislikes: 0, regenerations: 0 });\n\n  const handleGoalLike = async (goalId: string) => {\n    try {\n      await api.goals.provideFeedback(goalId, 'like');\n      setFeedbackStats(prev => ({ ...prev, likes: prev.likes + 1 }));\n      // 피드백 분석 이벤트 추적\n      analytics.track('goal_feedback', { type: 'like', goalId });\n    } catch (error) {\n      console.error('Failed to submit like feedback:', error);\n      toast.error('피드백 제출 중 오류가 발생했습니다');\n    }\n  };\n\n  const handleGoalDislike = async (goalId: string) => {\n    try {\n      await api.goals.provideFeedback(goalId, 'dislike');\n      setFeedbackStats(prev => ({ ...prev, dislikes: prev.dislikes + 1 }));\n      analytics.track('goal_feedback', { type: 'dislike', goalId });\n    } catch (error) {\n      console.error('Failed to submit dislike feedback:', error);\n      toast.error('피드백 제출 중 오류가 발생했습니다');\n    }\n  };\n\n  const handleGoalRegenerate = async (goalId: string) => {\n    if (isRegenerating[goalId]) return;\n    \n    setIsRegenerating(prev => ({ ...prev, [goalId]: true }));\n    try {\n      const newGoal = await api.goals.regenerate(goalId);\n      setGoals(prev => prev.map(g => g.id === goalId ? newGoal : g));\n      setFeedbackStats(prev => ({ ...prev, regenerations: prev.regenerations + 1 }));\n      analytics.track('goal_regenerate', { goalId });\n      toast.success('목표가 재생성되었습니다');\n    } catch (error) {\n      console.error('Failed to regenerate goal:', error);\n      toast.error('목표 재생성 중 오류가 발생했습니다');\n    } finally {\n      setIsRegenerating(prev => ({ ...prev, [goalId]: false }));\n    }\n  };\n\n  // ... 렌더링 코드 ...\n  return (\n    <div>\n      {/* ... 기존 UI ... */}\n      <div className=\"goals-container mt-4 space-y-3\">\n        {goals.map(goal => (\n          <div key={goal.id} className=\"goal-card p-3 border rounded-lg bg-white shadow-sm\">\n            <p className=\"text-gray-800\">{goal.content}</p>\n            <GoalFeedbackBar\n              goalId={goal.id}\n              onLike={handleGoalLike}\n              onDislike={handleGoalDislike}\n              onRegenerate={() => handleGoalRegenerate(goal.id)}\n              isRegenerating={isRegenerating[goal.id] || false}\n            />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n```\n\n### 피드백 데이터 활용 계획\n1. 사용자별 피드백 패턴 분석을 통한 목표 생성 알고리즘 개선\n2. 목표 품질 지표 대시보드 구현 (관리자용)\n3. 사용자 피드백 기반 목표 템플릿 자동 개선 시스템\n\n### 모바일 최적화\n- 터치 영역 확대 (최소 44x44px)\n- 피드백 버튼 간격 조정으로 오탭 방지\n- 재생성 중 로딩 상태 표시 강화\n- 진동 피드백 추가 (navigator.vibrate API 활용)\n\n### 접근성 개선\n- ARIA 속성 추가 (aria-pressed, aria-busy 등)\n- 키보드 네비게이션 지원\n- 고대비 모드 지원을 위한 색상 조정\n</info added on 2025-05-15T14:22:18.000Z>\n</info added on 2025-05-03T08:42:12.835Z>\n\n<info added on 2025-05-03T08:43:40.904Z>\n<info added on 2025-05-20T09:15:42.000Z>\n## DreamDetail 목표 관리 UX 개선 상세 설계\n\n### GoalCard 상태 관리 개선\n```typescript\n// GoalStatusControl.tsx\nconst GoalStatusControl: React.FC<{\n  goal: Goal;\n  onStatusChange: (goalId: string, newStatus: GoalStatus) => Promise<void>;\n}> = ({ goal, onStatusChange }) => {\n  const [isUpdating, setIsUpdating] = useState(false);\n  \n  const handleStatusChange = async (newStatus: GoalStatus) => {\n    if (goal.status === newStatus || isUpdating) return;\n    \n    setIsUpdating(true);\n    try {\n      await onStatusChange(goal.id, newStatus);\n      // 성공 시 시각적 피드백\n      toast.success(`목표가 ${getStatusLabel(newStatus)} 상태로 변경되었습니다`);\n    } catch (error) {\n      console.error('Status change failed:', error);\n      toast.error('상태 변경 중 오류가 발생했습니다');\n    } finally {\n      setIsUpdating(false);\n    }\n  };\n  \n  return (\n    <div className=\"goal-status-controls flex items-center space-x-2 mt-2\">\n      {isUpdating ? (\n        <Spinner size=\"sm\" className=\"text-primary\" />\n      ) : (\n        <>\n          <StatusButton \n            status=\"accepted\"\n            currentStatus={goal.status}\n            onClick={() => handleStatusChange('accepted')}\n            icon={<CheckIcon />}\n            label=\"수락\"\n          />\n          <StatusButton \n            status=\"rejected\"\n            currentStatus={goal.status}\n            onClick={() => handleStatusChange('rejected')}\n            icon={<XIcon />}\n            label=\"거부\"\n          />\n          <StatusButton \n            status=\"completed\"\n            currentStatus={goal.status}\n            onClick={() => handleStatusChange('completed')}\n            icon={<CheckCircleIcon />}\n            label=\"완료\"\n          />\n        </>\n      )}\n    </div>\n  );\n};\n\n// StatusButton 컴포넌트 - 상태별 스타일링 적용\nconst StatusButton: React.FC<{\n  status: GoalStatus;\n  currentStatus: GoalStatus;\n  onClick: () => void;\n  icon: React.ReactNode;\n  label: string;\n}> = ({ status, currentStatus, onClick, icon, label }) => {\n  const isActive = status === currentStatus;\n  \n  // 상태별 스타일 매핑\n  const styles = {\n    accepted: {\n      active: 'bg-green-100 text-green-700 border-green-300',\n      inactive: 'hover:bg-green-50 text-gray-600'\n    },\n    rejected: {\n      active: 'bg-red-100 text-red-700 border-red-300',\n      inactive: 'hover:bg-red-50 text-gray-600'\n    },\n    completed: {\n      active: 'bg-blue-100 text-blue-700 border-blue-300',\n      inactive: 'hover:bg-blue-50 text-gray-600'\n    },\n    pending: {\n      active: 'bg-yellow-100 text-yellow-700 border-yellow-300',\n      inactive: 'hover:bg-yellow-50 text-gray-600'\n    }\n  };\n  \n  const buttonStyle = isActive ? styles[status].active : styles[status].inactive;\n  \n  return (\n    <button\n      onClick={onClick}\n      className={`flex items-center px-3 py-1 rounded-full border text-sm transition-colors ${buttonStyle}`}\n      aria-pressed={isActive}\n      aria-label={`${label} 상태로 변경`}\n    >\n      <span className=\"mr-1\">{icon}</span>\n      {label}\n    </button>\n  );\n};\n```\n\n### 우선순위 관리 최적화\n```typescript\n// GoalPriorityManager.tsx\nconst GoalPriorityManager: React.FC<{\n  goals: Goal[];\n  onPriorityChange: (reorderedGoals: Goal[]) => Promise<void>;\n}> = ({ goals, onPriorityChange }) => {\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [localGoals, setLocalGoals] = useState<Goal[]>(goals);\n  \n  // 서버와 로컬 상태 동기화\n  useEffect(() => {\n    setLocalGoals(goals);\n  }, [goals]);\n  \n  const handleDragEnd = async (result: DropResult) => {\n    if (!result.destination) return;\n    \n    const { source, destination } = result;\n    if (source.index === destination.index) return;\n    \n    // 로컬 상태 즉시 업데이트 (낙관적 UI 업데이트)\n    const reordered = Array.from(localGoals);\n    const [removed] = reordered.splice(source.index, 1);\n    reordered.splice(destination.index, 0, removed);\n    \n    setLocalGoals(reordered);\n    setIsUpdating(true);\n    \n    try {\n      // 서버에 우선순위 변경 요청\n      await onPriorityChange(reordered);\n      // 분석 이벤트 추적\n      analytics.track('goal_priority_changed', {\n        goalId: removed.id,\n        oldPosition: source.index,\n        newPosition: destination.index\n      });\n    } catch (error) {\n      console.error('Priority update failed:', error);\n      toast.error('우선순위 변경 중 오류가 발생했습니다');\n      // 실패 시 원래 상태로 복원\n      setLocalGoals(goals);\n    } finally {\n      setIsUpdating(false);\n    }\n  };\n  \n  return (\n    <div className=\"goal-priority-manager\">\n      {isUpdating && (\n        <div className=\"text-sm text-blue-600 mb-2 flex items-center\">\n          <SyncIcon className=\"animate-spin h-4 w-4 mr-1\" />\n          우선순위 저장 중...\n        </div>\n      )}\n      \n      <DragDropContext onDragEnd={handleDragEnd}>\n        <Droppable droppableId=\"goals-list\">\n          {(provided) => (\n            <div\n              {...provided.droppableProps}\n              ref={provided.innerRef}\n              className=\"space-y-3\"\n            >\n              {localGoals.map((goal, index) => (\n                <Draggable \n                  key={goal.id} \n                  draggableId={goal.id} \n                  index={index}\n                  isDragDisabled={isUpdating}\n                >\n                  {(provided, snapshot) => (\n                    <div\n                      ref={provided.innerRef}\n                      {...provided.draggableProps}\n                      className={`transition-shadow ${\n                        snapshot.isDragging ? 'shadow-lg' : 'shadow-sm'\n                      }`}\n                    >\n                      <GoalCard \n                        goal={goal}\n                        dragHandleProps={provided.dragHandleProps}\n                        isDragging={snapshot.isDragging}\n                      />\n                    </div>\n                  )}\n                </Draggable>\n              ))}\n              {provided.placeholder}\n            </div>\n          )}\n        </Droppable>\n      </DragDropContext>\n    </div>\n  );\n};\n```\n\n### 개선된 GoalCard 컴포넌트\n```typescript\n// GoalCard.tsx\nconst GoalCard: React.FC<{\n  goal: Goal;\n  dragHandleProps?: DraggableProvidedDragHandleProps;\n  isDragging?: boolean;\n}> = ({ goal, dragHandleProps, isDragging = false }) => {\n  const { handleStatusChange, handleFeedback, isUpdating } = useGoalActions();\n  \n  return (\n    <div \n      className={`goal-card p-4 border rounded-lg bg-white ${\n        isDragging ? 'border-blue-400' : 'border-gray-200'\n      } ${goal.status === 'completed' ? 'bg-gray-50' : ''}`}\n    >\n      <div className=\"flex items-start\">\n        <div \n          {...dragHandleProps} \n          className=\"drag-handle mr-2 cursor-grab text-gray-400 hover:text-gray-600\"\n          aria-label=\"목표 순서 변경\"\n        >\n          <DragHandleIcon className=\"h-5 w-5\" />\n        </div>\n        \n        <div className=\"flex-1\">\n          <div className=\"flex items-center mb-1\">\n            <GoalStatusBadge status={goal.status} />\n            <span className=\"ml-auto text-sm text-gray-500\">\n              우선순위: {goal.priority}\n            </span>\n          </div>\n          \n          <p className={`text-gray-800 ${goal.status === 'completed' ? 'line-through text-gray-500' : ''}`}>\n            {goal.content}\n          </p>\n          \n          <div className=\"mt-3 flex flex-wrap gap-2\">\n            <GoalStatusControl \n              goal={goal} \n              onStatusChange={handleStatusChange}\n              isUpdating={isUpdating[goal.id]?.status || false}\n            />\n            \n            <GoalFeedbackControls\n              goalId={goal.id}\n              currentFeedback={goal.userFeedback}\n              onFeedback={handleFeedback}\n              isUpdating={isUpdating[goal.id]?.feedback || false}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// 목표 상태 뱃지 컴포넌트\nconst GoalStatusBadge: React.FC<{ status: GoalStatus }> = ({ status }) => {\n  const statusConfig = {\n    pending: { label: '대기중', className: 'bg-yellow-100 text-yellow-800' },\n    accepted: { label: '수락됨', className: 'bg-green-100 text-green-800' },\n    rejected: { label: '거부됨', className: 'bg-red-100 text-red-800' },\n    completed: { label: '완료됨', className: 'bg-blue-100 text-blue-800' }\n  };\n  \n  const { label, className } = statusConfig[status];\n  \n  return (\n    <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${className}`}>\n      {label}\n    </span>\n  );\n};\n```\n\n### 목표 관리 커스텀 훅\n```typescript\n// useGoalActions.ts\nexport const useGoalActions = () => {\n  const [isUpdating, setIsUpdating] = useState<Record<string, { \n    status?: boolean;\n    feedback?: boolean;\n  }>>({});\n  \n  const handleStatusChange = async (goalId: string, newStatus: GoalStatus) => {\n    setIsUpdating(prev => ({\n      ...prev,\n      [goalId]: { ...prev[goalId], status: true }\n    }));\n    \n    try {\n      await api.goals.updateStatus(goalId, newStatus);\n      return true;\n    } catch (error) {\n      console.error('Status update failed:', error);\n      return false;\n    } finally {\n      setIsUpdating(prev => ({\n        ...prev,\n        [goalId]: { ...prev[goalId], status: false }\n      }));\n    }\n  };\n  \n  const handleFeedback = async (goalId: string, feedback: 'like' | 'dislike' | null) => {\n    setIsUpdating(prev => ({\n      ...prev,\n      [goalId]: { ...prev[goalId], feedback: true }\n    }));\n    \n    try {\n      await api.goals.provideFeedback(goalId, feedback);\n      return true;\n    } catch (error) {\n      console.error('Feedback submission failed:', error);\n      return false;\n    } finally {\n      setIsUpdating(prev => ({\n        ...prev,\n        [goalId]: { ...prev[goalId], feedback: false }\n      }));\n    }\n  };\n  \n  return {\n    isUpdating,\n    handleStatusChange,\n    handleFeedback\n  };\n};\n```\n\n### 모바일 및 접근성 최적화\n```typescript\n// GoalCardAccessibility.tsx - 접근성 강화 래퍼 컴포넌트\nconst GoalCardAccessibility: React.FC<{ goal: Goal }> = ({ goal }) => {\n  // 키보드 네비게이션 핸들러\n  const handleKeyDown = (e: React.KeyboardEvent, action: () => void) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      action();\n    }\n  };\n  \n  // 모바일 터치 최적화\n  const touchProps = {\n    role: 'button',\n    tabIndex: 0,\n    style: { \n      // 터치 영역 최소 44x44px 보장\n      minHeight: '44px',\n      minWidth: '44px'\n    }\n  };\n  \n  // 스크린 리더 지원\n  const getAriaLabel = (status: GoalStatus) => {\n    const statusLabels = {\n      pending: '대기 중인',\n      accepted: '수락된',\n      rejected: '거부된',\n      completed: '완료된'\n    };\n    \n    return `${statusLabels[status]} 목표: ${goal.content}`;\n  };\n  \n  return (\n    <div \n      role=\"region\"\n      aria-label={getAriaLabel(goal.status)}\n      className=\"goal-card-accessible\"\n    >\n      {/* 기존 GoalCard 컴포넌트에 접근성 속성 추가 */}\n      <GoalCard \n        goal={goal}\n        ariaProps={{\n          'aria-label': getAriaLabel(goal.status),\n          role: 'article'\n        }}\n        touchProps={touchProps}\n        keyboardProps={{\n          onKeyDown: handleKeyDown\n        }}\n      />\n    </div>\n  );\n};\n\n// 모바일 최적화 스타일\nconst mobileOptimizedStyles = css`\n  @media (max-width: 640px) {\n    .goal-card {\n      padding: 16px 12px;\n    }\n    \n    .goal-status-controls {\n      flex-wrap: wrap;\n      gap: 8px;\n    }\n    \n    .goal-status-button {\n      min-height: 44px;\n      min-width: 44px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n    \n    /* 터치 영역 간격 확보 */\n    .goal-feedback-controls button {\n      margin: 0 8px;\n    }\n  }\n`;\n```\n\n### 실시간 UI 업데이트 및 서버 연동\n```typescript\n// DreamDetailGoals.tsx\nconst DreamDetailGoals: React.FC<{ dreamId: string }> = ({ dreamId }) => {\n  const { data: goals, isLoading, mutate } = useSWR(\n    `/api/dreams/${dreamId}/goals`,\n    () => api.goals.getByDreamId(dreamId)\n  );\n  \n  // 낙관적 UI 업데이트 + 서버 연동\n  const updateGoalStatus = async (goalId: string, newStatus: GoalStatus) => {\n    // 현재 데이터 복사\n    const currentGoals = [...(goals || [])];\n    \n    // 낙관적 UI 업데이트\n    const updatedGoals = currentGoals.map(goal => \n      goal.id === goalId ? { ...goal, status: newStatus } : goal\n    );\n    \n    // SWR 캐시 즉시 업데이트\n    mutate(updatedGoals, false);\n    \n    try {\n      // 서버 요청\n      await api.goals.updateStatus(goalId, newStatus);\n      // 성공 시 최신 데이터로 갱신\n      mutate();\n    } catch (error) {\n      console.error('Status update failed:', error);\n      // 실패 시 원래 데이터로 복원\n      mutate(currentGoals, false);\n      throw error;\n    }\n  };\n  \n  const updateGoalPriorities = async (reorderedGoals: Goal[]) => {\n    // 현재 데이터 백업\n    const currentGoals = [...(goals || [])];\n    \n    // 낙관적 UI 업데이트\n    mutate(reorderedGoals, false);\n    \n    try {\n      // 서버에 우선순위 업데이트 요청\n      await api.goals.updatePriorities(\n        dreamId,\n        reorderedGoals.map((goal, index) => ({ \n          id: goal.id, \n          priority: index + 1 \n        }))\n      );\n      // 성공 시 최신 데이터 갱신\n      mutate();\n    } catch (error) {\n      console.error('Priority update failed:', error);\n      // 실패 시 원래 데이터로 복원\n      mutate(currentGoals, false);\n      throw error;\n    }\n  };\n  \n  if (isLoading) return <GoalListSkeleton />;\n  \n  return (\n    <div className=\"dream-goals-container\">\n      <h2 className=\"text-xl font-semibold mb-4\">목표 관리</h2>\n      \n      {goals?.length === 0 ? (\n        <EmptyGoalState dreamId={dreamId} onGoalsGenerated={mutate} />\n      ) : (\n        <GoalPriorityManager\n          goals={goals || []}\n          onPriorityChange={updateGoalPriorities}\n        />\n      )}\n    </div>\n  );\n};\n```\n\n### 성능 최적화 및 사용자 경험 향상\n- 목표 상태 변경 시 애니메이션 효과 추가\n- 목표 목록이 많을 경우 가상화(virtualization) 적용\n- 목표 관리 작업 중 실시간 피드백 제공\n- 오프라인 지원을 위한 상태 캐싱 및 동기화 메커니즘\n</info added on 2025-05-20T09:15:42.000Z>\n</info added on 2025-05-03T08:43:40.904Z>",
          "status": "in-progress",
          "parentTaskId": 3
        }
      ]
    },
    {
      "id": 4,
      "title": "[1차] 꿈 시각화 도구 생성",
      "description": "사용자가 꿈을 시각화할 수 있는 대화형 드래그 앤 드롭 인터페이스 구축",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "react-dnd 또는 react-beautiful-dnd와 같은 라이브러리를 사용하여 캔버스 기반 시각화 도구를 구현합니다. 텍스트, 이미지, 색상 및 기타 시각적 요소를 추가하기 위한 컴포넌트를 만듭니다. Supabase Storage를 사용하여 이미지 업로드 기능을 설정합니다. 시각화 데이터에 대한 저장/로드 기능을 구현합니다. 시각화를 이미지로 저장하는 내보내기 옵션을 추가합니다. 꿈 모델에 저장될 시각화 데이터 구조를 설계합니다.",
      "testStrategy": "다양한 브라우저에서 드래그 앤 드롭 기능을 테스트합니다. 이미지 업로드 및 렌더링을 확인합니다. 시각화 상태 저장 및 로드를 테스트합니다. 내보내기 기능이 사용 가능한 이미지 파일을 생성하는지 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "캔버스 기반 드래그 앤 드롭 인터페이스 구현",
          "description": "react-beautiful-dnd 라이브러리를 사용하여 기본 캔버스 영역과 드래그 앤 드롭 기능을 구현합니다.",
          "dependencies": [],
          "details": "1. react-beautiful-dnd 라이브러리 설치\n2. 캔버스 컴포넌트 생성 (Canvas.tsx)\n3. 드래그 가능한 영역(DraggableArea)과 드롭 영역(DropArea) 컴포넌트 구현\n4. 캔버스 내에서 요소 위치 조정 기능 구현\n5. 캔버스 크기 조절 및 확대/축소 기능 추가\n6. 테스트: 간단한 요소를 드래그하여 캔버스에 배치하고 위치 조정이 가능한지 확인",
          "status": "pending",
          "parentTaskId": 4
        },
        {
          "id": 2,
          "title": "시각화 요소 컴포넌트 개발",
          "description": "꿈 시각화에 필요한 다양한 시각적 요소(텍스트, 이미지, 도형, 색상 등)를 위한 컴포넌트를 개발합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 텍스트 요소 컴포넌트 구현 (크기, 색상, 폰트 조절 가능)\n2. 이미지 요소 컴포넌트 구현 (크기 조절, 회전 기능 포함)\n3. 도형 요소 컴포넌트 구현 (원, 사각형, 삼각형 등)\n4. 색상 팔레트 컴포넌트 구현\n5. 요소 속성 편집 패널 구현 (선택된 요소의 속성 변경)\n6. 테스트: 각 컴포넌트가 캔버스에 추가되고 속성이 올바르게 편집되는지 확인",
          "status": "pending",
          "parentTaskId": 4
        },
        {
          "id": 3,
          "title": "Supabase Storage 이미지 업로드 기능 구현",
          "description": "사용자가 자신의 이미지를 업로드하고 시각화에 사용할 수 있도록 Supabase Storage 연동 기능을 구현합니다.",
          "dependencies": [
            2
          ],
          "details": "1. Supabase 클라이언트 설정 및 Storage 버킷 생성\n2. 이미지 업로드 컴포넌트 구현 (ImageUploader.tsx)\n3. 드래그 앤 드롭 또는 파일 선택을 통한 이미지 업로드 기능 구현\n4. 업로드 진행 상태 표시 기능 추가\n5. 업로드된 이미지 미리보기 및 캔버스에 추가 기능 구현\n6. 테스트: 이미지 업로드 후 스토리지에 저장되고 캔버스에 추가되는지 확인",
          "status": "pending",
          "parentTaskId": 4
        },
        {
          "id": 4,
          "title": "시각화 데이터 구조 설계 및 상태 관리 구현",
          "description": "시각화 요소들의 데이터 구조를 설계하고 상태 관리 시스템을 구현하여 요소들의 추가, 수정, 삭제를 관리합니다.",
          "dependencies": [
            2,
            3
          ],
          "details": "1. 시각화 데이터 모델 정의 (요소 유형, 위치, 크기, 스타일 등 포함)\n2. Redux 또는 Context API를 사용한 상태 관리 시스템 구현\n3. 요소 추가, 수정, 삭제, 순서 변경 액션 구현\n4. 실행 취소/다시 실행(Undo/Redo) 기능 구현\n5. 선택된 요소 상태 관리 구현\n6. 테스트: 요소 추가, 수정, 삭제 및 실행 취소/다시 실행 기능이 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 4
        },
        {
          "id": 5,
          "title": "시각화 저장 및 불러오기 기능 구현",
          "description": "사용자의 시각화 작업을 Supabase 데이터베이스에 저장하고 불러올 수 있는 기능을 구현합니다.",
          "dependencies": [
            4
          ],
          "details": "1. Dream 테이블에 시각화 데이터를 저장할 필드 추가\n2. 저장 기능 구현 (현재 캔버스 상태를 JSON으로 변환하여 저장)\n3. 자동 저장 기능 구현 (일정 시간마다 또는 변경 시)\n4. 저장된 시각화 불러오기 기능 구현\n5. 테스트: 시각화 저장 후 다시 불러왔을 때 모든 요소와 속성이 정확히 복원되는지 확인",
          "status": "pending",
          "parentTaskId": 4
        },
        {
          "id": 6,
          "title": "시각화 내보내기 기능 구현",
          "description": "완성된 시각화를 이미지 파일로 내보내는 기능을 구현합니다.",
          "dependencies": [
            4,
            5
          ],
          "details": "1. html2canvas 또는 dom-to-image 라이브러리 설치\n2. 캔버스 영역을 이미지로 변환하는 기능 구현\n3. 다양한 이미지 형식(PNG, JPEG, SVG 등) 지원 구현\n4. 이미지 해상도 및 품질 옵션 설정 기능 추가\n5. 내보낸 이미지를 다운로드하거나 소셜 미디어에 공유하는 기능 구현\n6. 테스트: 다양한 요소가 포함된 시각화를 여러 형식으로 내보내고 품질 확인",
          "status": "pending",
          "parentTaskId": 4
        }
      ]
    },
    {
      "id": 5,
      "title": "[MVP] 목표 관리 인터페이스 개발",
      "description": "목표 보기, 추적 및 관리를 위한 종합적인 UI 생성",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "전체 목표 목록과 꿈별 목표 목록을 볼 수 있는 뷰를 설계하고 구현합니다. 목표 완료 추적을 위한 대화형 체크리스트를 만듭니다. 진행 시각화 컴포넌트(진행 막대, 차트)를 구축합니다. 목표 편집, 삭제 및 상태 업데이트 기능을 구현합니다. 목표에 대한 필터링 및 정렬 옵션을 추가합니다. 완료 상태 및 기록을 추적하도록 목표 모델을 업데이트합니다.",
      "testStrategy": "목표 CRUD 작업을 테스트합니다. 진행 추적 정확도를 확인합니다. 많은 목표가 있는 UI 응답성을 테스트합니다. 목표 상태 업데이트가 데이터베이스 및 UI에 반영되는지 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "목표 목록 UI 구현",
          "description": "전체 목표 목록과 꿈별 목표 목록을 볼 수 있는 UI 컴포넌트를 구현합니다.",
          "dependencies": [],
          "details": "1. 목표 탭에서 모든 목표를 보여주는 목록 컴포넌트 구현\n2. 꿈 상세 페이지에서 해당 꿈의 목표만 보여주는 목록 컴포넌트 구현\n3. 목표 카드 컴포넌트 디자인 및 구현 (목표 내용, 상태, 진행률 표시)\n4. 목표 필터링 기능 구현 (완료/미완료, 날짜별 등)\n5. 목표 정렬 기능 구현 (생성일, 마감일, 우선순위 등)\n6. 페이지네이션 또는 무한 스크롤 구현\n7. 테스트: 다양한 필터 및 정렬 옵션으로 목표 목록이 올바르게 표시되는지 확인",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 2,
          "title": "목표 체크리스트 및 진행률 UI 구현",
          "description": "목표 완료 추적을 위한 체크리스트와 진행률 시각화 컴포넌트를 개발합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 목표 체크리스트 컴포넌트 구현 (체크박스, 완료 상태 토글)\n2. 진행률 표시 컴포넌트 구현 (프로그레스 바)\n3. 목표 완료 시 시각적 피드백 제공 (애니메이션, 색상 변경 등)\n4. 목표 상태 변경 시 실시간 UI 업데이트 구현\n5. 테스트: 체크리스트 항목 완료/미완료 토글 시 진행률이 올바르게 업데이트되는지 확인",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 3,
          "title": "목표 CRUD 기능 구현",
          "description": "목표 생성, 조회, 수정, 삭제 기능을 위한 UI 및 API 연동을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 목표 생성 폼/모달 구현\n2. 목표 상세 보기 페이지/모달 구현\n3. 목표 편집 폼/모달 구현\n4. 목표 삭제 확인 대화상자 구현\n5. 각 CRUD 작업에 대한 API 연동 구현\n6. 유효성 검사 및 오류 처리 구현\n7. 테스트: 모든 CRUD 작업이 UI와 데이터베이스에 올바르게 반영되는지 확인",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 4,
          "title": "목표 상태 관리 기능 구현",
          "description": "목표의 상태(진행 중, 완료 등)를 관리하고 업데이트하는 기능을 구현합니다.",
          "dependencies": [
            2,
            3
          ],
          "details": "1. 목표 상태 모델 정의 (진행 중, 완료, 지연됨 등)\n2. 상태 변경 UI 컴포넌트 구현 (드롭다운, 버튼 등)\n3. 상태 변경 API 연동 구현\n4. 상태에 따른 시각적 표시 구현 (색상, 아이콘 등)\n5. 상태 변경 히스토리 추적 기능 구현 (선택적)\n6. 테스트: 상태 변경이 UI와 데이터베이스에 올바르게 반영되는지 확인",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 5,
          "title": "목표 데이터 모델 확장 및 API 업데이트",
          "description": "목표 완료 상태 및 진행률 추적을 위해 데이터 모델을 확장하고 API를 업데이트합니다.",
          "dependencies": [
            3,
            4
          ],
          "details": "1. Goal 테이블에 진행률(progress) 필드 추가\n2. Goal 테이블에 완료 날짜(completedAt) 필드 추가\n3. Goal 테이블에 상태(status) 필드 추가 또는 확장\n4. 진행률 및 상태 업데이트를 위한 API 엔드포인트 구현\n5. 목표 완료 시 completedAt 자동 설정 로직 구현\n6. 테스트: 데이터 모델 변경 후 API가 올바르게 작동하는지 확인",
          "status": "done",
          "parentTaskId": 5
        }
      ]
    },
    {
      "id": 6,
      "title": "[1차] 집중 타이머 기능 구현",
      "description": "사용자가 목표에 집중할 수 있도록 돕는 뽀모도로 및 커스텀 타이머 기능 구축",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "뽀모도로 프리셋(25/5분 작업/휴식 주기) 및 사용자 지정 기간 옵션이 있는 타이머 컴포넌트를 만듭니다. 타이머 컨트롤(시작, 일시 중지, 재설정, 건너뛰기)을 구현합니다. Supabase에서 타이머 세션 데이터 모델을 구축합니다. 타이머 세션을 특정 목표와 연결하는 기능을 추가합니다. 세션 기록 및 통계를 구현합니다. 타이머 이벤트에 대한 시각적 및 오디오 알림을 만듭니다.",
      "testStrategy": "다양한 세션 기간에 걸쳐 타이머 정확도를 테스트합니다. 사용자가 다른 페이지로 이동해도 타이머 상태가 유지되는지 확인합니다. 타이머 세션과 목표 간의 연결을 테스트합니다. 타이머 통계가 올바르게 계산되고 저장되는지 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "타이머 UI 컴포넌트 개발",
          "description": "뽀모도로 및 커스텀 타이머를 위한 UI 컴포넌트를 개발합니다.",
          "dependencies": [],
          "details": "1. 타이머 디스플레이 컴포넌트 구현 (시간, 분, 초 표시)\n2. 타이머 컨트롤 버튼 구현 (시작, 일시 중지, 재설정, 건너뛰기)\n3. 뽀모도로 프리셋 선택 UI 구현 (25/5, 50/10 등)\n4. 커스텀 타이머 설정 UI 구현 (사용자 지정 작업/휴식 시간)\n5. 현재 타이머 상태 표시 (작업 중, 휴식 중)\n6. 반응형 디자인 적용\n7. 테스트: 타이머 UI가 모든 상태에서 올바르게 표시되는지 확인",
          "status": "pending",
          "parentTaskId": 6
        },
        {
          "id": 2,
          "title": "타이머 로직 및 상태 관리 구현",
          "description": "타이머 기능의 핵심 로직과 상태 관리를 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 타이머 카운트다운 로직 구현\n2. 작업/휴식 주기 전환 로직 구현\n3. 타이머 상태 관리 (실행 중, 일시 중지, 중지)\n4. 브라우저 탭 전환 시 타이머 정확성 유지 로직 구현\n5. 로컬 스토리지를 사용한 타이머 상태 유지 구현\n6. 테스트: 다양한 시나리오에서 타이머 로직이 정확하게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 6
        },
        {
          "id": 3,
          "title": "타이머 세션 데이터 모델 및 API 구현",
          "description": "타이머 세션을 저장하고 관리하기 위한 데이터 모델과 API를 구현합니다.",
          "dependencies": [
            2
          ],
          "details": "1. Supabase에 타이머 세션 테이블 생성 (user_id, goal_id, start_time, end_time, duration, type 등 포함)\n2. 세션 시작 API 엔드포인트 구현\n3. 세션 종료/업데이트 API 엔드포인트 구현\n4. 세션 조회 API 엔드포인트 구현\n5. 목표별 세션 통계 API 엔드포인트 구현\n6. 테스트: API 엔드포인트가 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 6
        },
        {
          "id": 4,
          "title": "목표 연결 기능 구현",
          "description": "타이머 세션을 특정 목표와 연결하는 기능을 구현합니다.",
          "dependencies": [
            2,
            3
          ],
          "details": "1. 타이머 시작 전 목표 선택 UI 구현\n2. 최근/자주 사용한 목표 빠른 선택 기능 구현\n3. 선택한 목표 정보 표시 UI 구현\n4. 세션 중 목표 변경 기능 구현 (선택적)\n5. 목표 없이 타이머 사용 옵션 구현\n6. 테스트: 목표 선택 및 연결 기능이 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 6
        },
        {
          "id": 5,
          "title": "타이머 알림 기능 구현",
          "description": "타이머 이벤트(시작, 종료, 휴식 등)에 대한 시각적 및 오디오 알림을 구현합니다.",
          "dependencies": [
            2
          ],
          "details": "1. 브라우저 알림 API 통합\n2. 알림 소리 선택 옵션 구현\n3. 타이머 종료 시 시각적 피드백 구현 (애니메이션, 색상 변경 등)\n4. 작업/휴식 전환 시 알림 구현\n5. 알림 설정 UI 구현 (소리 켜기/끄기, 볼륨 등)\n6. 테스트: 다양한 브라우저에서 알림이 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 6
        },
        {
          "id": 6,
          "title": "타이머 통계 및 기록 UI 구현",
          "description": "사용자의 타이머 사용 기록과 통계를 보여주는 UI를 구현합니다.",
          "dependencies": [
            3,
            4
          ],
          "details": "1. 일별/주별/월별 타이머 사용 통계 차트 구현\n2. 목표별 집중 시간 통계 구현\n3. 타이머 세션 기록 목록 UI 구현\n4. 통계 필터링 및 정렬 옵션 구현\n5. 통계 데이터 내보내기 기능 구현 (선택적)\n6. 테스트: 통계 및 기록 UI가 올바른 데이터를 표시하는지 확인",
          "status": "pending",
          "parentTaskId": 6
        }
      ]
    },
    {
      "id": 7,
      "title": "[2차] 알림 시스템 설정",
      "description": "리마인더 및 동기부여 콘텐츠를 위한 웹 푸시 알림 구현",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "low",
      "details": "Web Push API 통합을 설정합니다. 예약된 알림을 위한 Supabase Edge Functions를 구성합니다. 알림 권한 요청 흐름을 구현합니다. 다양한 유형(목표 리마인더, 동기부여 메시지)에 대한 알림 템플릿을 만듭니다. 설정에서 알림 기본 설정 UI를 구축합니다. 사용자 기본 설정 및 목표 마감일에 따라 알림 일정을 구현합니다.",
      "testStrategy": "다양한 브라우저에서 알림 전달을 테스트합니다. 예약된 알림이 올바른 시간에 트리거되는지 확인합니다. 알림에 대한 권한 처리를 테스트합니다. 알림 기본 설정이 존중되는지 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "Web Push API 통합 설정",
          "description": "웹 푸시 알림을 위한 기본 인프라를 설정합니다.",
          "dependencies": [],
          "details": "1. 웹 푸시 라이브러리 설치 (web-push, firebase-messaging 등)\n2. 서비스 워커 설정 및 등록\n3. 푸시 알림 구독 관리 구현\n4. 알림 권한 요청 UI 구현\n5. 브라우저 호환성 처리\n6. 테스트: 다양한 브라우저에서 기본 푸시 알림 작동 확인",
          "status": "pending",
          "parentTaskId": 7
        },
        {
          "id": 2,
          "title": "Supabase Edge Functions 설정",
          "description": "예약된 알림을 처리하기 위한 Supabase Edge Functions를 설정합니다.",
          "dependencies": [
            1
          ],
          "details": "1. Supabase CLI 설치 및 설정\n2. Edge Function 프로젝트 구조 설정\n3. 알림 처리 함수 구현\n4. 예약된 작업 처리 로직 구현\n5. 함수 배포 및 테스트\n6. 테스트: Edge Function이 예약된 시간에 실행되는지 확인",
          "status": "pending",
          "parentTaskId": 7
        },
        {
          "id": 3,
          "title": "알림 데이터 모델 및 API 구현",
          "description": "알림 설정 및 기록을 저장하기 위한 데이터 모델과 API를 구현합니다.",
          "dependencies": [
            2
          ],
          "details": "1. Supabase에 알림 설정 테이블 생성 (user_id, type, enabled, time_preferences 등)\n2. 알림 기록 테이블 생성 (user_id, type, content, sent_at, read 등)\n3. 알림 설정 CRUD API 구현\n4. 알림 기록 조회 및 관리 API 구현\n5. 알림 읽음 상태 업데이트 API 구현\n6. 테스트: API 엔드포인트가 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 7
        },
        {
          "id": 4,
          "title": "알림 템플릿 및 콘텐츠 관리 구현",
          "description": "다양한 유형의 알림을 위한 템플릿과 콘텐츠 관리 시스템을 구현합니다.",
          "dependencies": [
            3
          ],
          "details": "1. 목표 리마인더 알림 템플릿 구현\n2. 동기부여 메시지 알림 템플릿 구현\n3. 시스템 알림 템플릿 구현\n4. 알림 콘텐츠 생성 및 관리 로직 구현\n5. 알림 우선순위 및 그룹화 로직 구현\n6. 테스트: 다양한 템플릿으로 알림이 올바르게 생성되는지 확인",
          "status": "pending",
          "parentTaskId": 7
        },
        {
          "id": 5,
          "title": "알림 설정 UI 구현",
          "description": "사용자가 알림 기본 설정을 관리할 수 있는 UI를 구현합니다.",
          "dependencies": [
            3,
            4
          ],
          "details": "1. 알림 유형별 켜기/끄기 토글 UI 구현\n2. 알림 시간 및 빈도 설정 UI 구현\n3. 알림 소리 및 진동 설정 UI 구현\n4. 방해 금지 시간 설정 UI 구현\n5. 설정 변경 시 실시간 업데이트 구현\n6. 테스트: 설정 변경이 저장되고 알림에 올바르게 적용되는지 확인",
          "status": "pending",
          "parentTaskId": 7
        },
        {
          "id": 6,
          "title": "알림 표시 및 관리 UI 구현",
          "description": "수신된 알림을 표시하고 관리하기 위한 UI를 구현합니다.",
          "dependencies": [
            4,
            5
          ],
          "details": "1. 알림 센터/드롭다운 UI 구현\n2. 알림 카드 컴포넌트 구현\n3. 읽음/안 읽음 상태 표시 및 관리 기능 구현\n4. 알림 삭제 및 모두 읽음 표시 기능 구현\n5. 알림 필터링 및 정렬 옵션 구현\n6. 테스트: 알림 UI가 모든 상태에서 올바르게 표시되는지 확인",
          "status": "pending",
          "parentTaskId": 7
        }
      ]
    },
    {
      "id": 8,
      "title": "[2차] 동기부여 콘텐츠 피드 생성",
      "description": "사용자 꿈과 관련된 동기부여 콘텐츠를 큐레이션하고 표시하는 시스템 개발",
      "status": "pending",
      "dependencies": [
        2,
        5
      ],
      "priority": "low",
      "details": "Supabase에서 MotivationContent 데이터 모델을 구현합니다. 다양한 콘텐츠 유형(인용구, 비디오, 기사)이 있는 콘텐츠 피드 UI를 만듭니다. 사용자 꿈에 대한 콘텐츠 태깅 및 관련성 매칭을 설정합니다. 기본 콘텐츠 추천 알고리즘을 구현합니다. 해당되는 경우 콘텐츠 소스에 대한 외부 API 통합을 추가합니다. 콘텐츠 북마크 기능을 만듭니다.",
      "testStrategy": "콘텐츠 로딩 및 표시를 테스트합니다. 사용자 꿈에 대한 콘텐츠 관련성을 확인합니다. 콘텐츠 필터링 및 정렬을 테스트합니다. 북마크 기능이 올바르게 작동하는지 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "동기부여 콘텐츠 데이터 모델 구현",
          "description": "동기부여 콘텐츠를 저장하고 관리하기 위한 데이터 모델을 구현합니다.",
          "dependencies": [],
          "details": "1. Supabase에 MotivationContent 테이블 생성 (type, title, content, source, tags 등 포함)\n2. 콘텐츠-꿈 관계 테이블 생성 (content_id, dream_id, relevance_score 등)\n3. 사용자 북마크 테이블 생성 (user_id, content_id, created_at 등)\n4. 콘텐츠 태그 테이블 생성 및 관계 설정\n5. 필요한 인덱스 및 외래 키 제약 조건 설정\n6. 테스트: 데이터 모델이 올바르게 작동하는지 CRUD 작업으로 확인",
          "status": "pending",
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "콘텐츠 관리 API 구현",
          "description": "동기부여 콘텐츠를 관리하기 위한 API를 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 콘텐츠 조회 API 엔드포인트 구현 (필터링, 정렬, 페이지네이션 포함)\n2. 꿈 관련 콘텐츠 조회 API 구현\n3. 콘텐츠 북마크 추가/제거 API 구현\n4. 북마크된 콘텐츠 조회 API 구현\n5. 콘텐츠 추천 API 구현\n6. 테스트: API 엔드포인트가 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "콘텐츠 태깅 및 관련성 매칭 시스템 구현",
          "description": "사용자 꿈과 콘텐츠 간의 관련성을 분석하고 매칭하는 시스템을 구현합니다.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. 콘텐츠 자동 태깅 시스템 구현 (키워드 추출 또는 AI 기반)\n2. 꿈 내용 분석 및 키워드 추출 로직 구현\n3. 콘텐츠-꿈 관련성 점수 계산 알고리즘 구현\n4. 관련성 기반 콘텐츠 추천 로직 구현\n5. 사용자 피드백 기반 추천 개선 시스템 구현 (선택적)\n6. 테스트: 다양한 꿈 시나리오에 대해 관련 콘텐츠가 올바르게 매칭되는지 확인",
          "status": "pending",
          "parentTaskId": 8
        },
        {
          "id": 4,
          "title": "외부 콘텐츠 소스 통합",
          "description": "외부 API를 통해 동기부여 콘텐츠를 가져오는 통합을 구현합니다.",
          "dependencies": [
            1,
            3
          ],
          "details": "1. 인용구 API 통합 (Quotable, They Said So 등)\n2. 동영상 콘텐츠 API 통합 (YouTube API 등)\n3. 기사/블로그 콘텐츠 API 통합 (Medium, RSS 피드 등)\n4. 외부 콘텐츠 가져오기 및 저장 로직 구현\n5. 콘텐츠 동기화 및 업데이트 스케줄러 구현\n6. 테스트: 외부 API에서 콘텐츠가 올바르게 가져와지고 저장되는지 확인",
          "status": "pending",
          "parentTaskId": 8
        },
        {
          "id": 5,
          "title": "콘텐츠 피드 UI 구현",
          "description": "사용자에게 동기부여 콘텐츠를 표시하기 위한 피드 UI를 구현합니다.",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "1. 메인 콘텐츠 피드 컴포넌트 구현\n2. 콘텐츠 카드 컴포넌트 구현 (다양한 콘텐츠 유형 지원)\n3. 콘텐츠 필터링 및 정렬 UI 구현\n4. 무한 스크롤 또는 페이지네이션 구현\n5. 콘텐츠 상세 보기 모달/페이지 구현\n6. 반응형 디자인 적용\n7. 테스트: 피드 UI가 다양한 콘텐츠 유형과 화면 크기에서 올바르게 표시되는지 확인",
          "status": "pending",
          "parentTaskId": 8
        },
        {
          "id": 6,
          "title": "콘텐츠 북마크 및 공유 기능 구현",
          "description": "사용자가 콘텐츠를 북마크하고 공유할 수 있는 기능을 구현합니다.",
          "dependencies": [
            2,
            5
          ],
          "details": "1. 콘텐츠 북마크 토글 버튼 구현\n2. 북마크된 콘텐츠 모아보기 페이지 구현\n3. 소셜 미디어 공유 기능 구현\n4. 콘텐츠 URL 복사 기능 구현\n5. 공유 통계 추적 기능 구현 (선택적)\n6. 테스트: 북마크 및 공유 기능이 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "[2차] 성취 및 피드백 시스템 구현",
      "description": "사용자 진행 상황을 추적하고, 피드백을 제공하며, 성취를 수여하는 시스템 구축",
      "status": "pending",
      "dependencies": [
        5,
        6
      ],
      "priority": "low",
      "details": "Supabase에서 Achievement 데이터 모델을 만듭니다. 사용자 행동 및 목표 완료에 기반한 성취 트리거를 구현합니다. 성취 배지 및 레벨을 설계하고 구현합니다. 사용자 진행 상황의 시각화가 포함된 주간/월간 보고서를 만듭니다. 일관된 목표 완료에 대한 연속 추적을 구현합니다. 성취 및 진행 보고서를 표시하기 위한 UI 컴포넌트를 구축합니다.",
      "testStrategy": "다양한 사용자 시나리오로 성취 트리거를 테스트합니다. 보고서 생성 정확도를 확인합니다. 연속 계산 로직을 테스트합니다. 성취가 올바르게 저장되고 표시되는지 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "성취 데이터 모델 구현",
          "description": "사용자 성취를 저장하고 관리하기 위한 데이터 모델을 구현합니다.",
          "dependencies": [],
          "details": "1. Supabase에 Achievement 테이블 생성 (id, name, description, icon, criteria 등 포함)\n2. 사용자 성취 테이블 생성 (user_id, achievement_id, earned_at 등)\n3. 성취 진행 테이블 생성 (진행형 성취를 위한 추적)\n4. 연속 기록 테이블 생성 (streak_id, user_id, type, current_count, max_count, last_date 등)\n5. 필요한 인덱스 및 외래 키 제약 조건 설정\n6. 테스트: 데이터 모델이 올바르게 작동하는지 CRUD 작업으로 확인",
          "status": "pending",
          "parentTaskId": 9
        },
        {
          "id": 2,
          "title": "성취 트리거 및 로직 구현",
          "description": "다양한 사용자 행동에 기반하여 성취를 트리거하는 로직을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 목표 완료 기반 성취 트리거 구현\n2. 연속 기록 기반 성취 트리거 구현\n3. 사용자 활동 기반 성취 트리거 구현 (로그인, 콘텐츠 상호작용 등)\n4. 특별 이벤트 성취 트리거 구현\n5. 성취 조건 검증 및 부여 로직 구현\n6. 테스트: 다양한 시나리오에서 성취 트리거가 올바르게 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 9
        },
        {
          "id": 3,
          "title": "연속 기록 추적 시스템 구현",
          "description": "사용자의 일관된 목표 완료 및 활동에 대한 연속 기록을 추적하는 시스템을 구현합니다.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. 일일 목표 완료 연속 기록 추적 로직 구현\n2. 앱 사용 연속 기록 추적 로직 구현\n3. 연속 기록 유지 및 중단 조건 정의\n4. 연속 기록 복구 메커니즘 구현 (선택적)\n5. 연속 기록 알림 및 리마인더 구현\n6. 테스트: 연속 기록이 다양한 시나리오에서 올바르게 계산되는지 확인",
          "status": "pending",
          "parentTaskId": 9
        },
        {
          "id": 4,
          "title": "진행 보고서 및 통계 시스템 구현",
          "description": "사용자 진행 상황에 대한 보고서와 통계를 생성하는 시스템을 구현합니다.",
          "dependencies": [
            1,
            3
          ],
          "details": "1. 일일/주간/월간 목표 완료율 계산 로직 구현\n2. 시간 경과에 따른 진행 추세 분석 구현\n3. 성취 및 연속 기록 통계 계산 구현\n4. 사용자 활동 요약 생성 로직 구현\n5. 맞춤형 피드백 및 제안 생성 로직 구현\n6. 테스트: 보고서 및 통계가 정확하게 계산되는지 확인",
          "status": "pending",
          "parentTaskId": 9
        },
        {
          "id": 5,
          "title": "성취 및 배지 UI 구현",
          "description": "사용자 성취와 배지를 표시하기 위한 UI를 구현합니다.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. 성취 목록 페이지 구현\n2. 성취 배지 컴포넌트 구현 (획득/미획득 상태 표시)\n3. 성취 상세 정보 모달/페이지 구현\n4. 성취 획득 알림 및 축하 애니메이션 구현\n5. 프로필에 표시할 대표 배지 선택 기능 구현\n6. 테스트: 성취 UI가 모든 상태에서 올바르게 표시되는지 확인",
          "status": "pending",
          "parentTaskId": 9
        },
        {
          "id": 6,
          "title": "진행 보고서 및 통계 UI 구현",
          "description": "사용자 진행 상황과 통계를 시각화하여 표시하는 UI를 구현합니다.",
          "dependencies": [
            4
          ],
          "details": "1. 진행 대시보드 페이지 구현\n2. 목표 완료율 차트 컴포넌트 구현\n3. 시간 경과에 따른 추세 그래프 구현\n4. 연속 기록 표시 컴포넌트 구현\n5. 주간/월간 요약 보고서 UI 구현\n6. 맞춤형 피드백 및 제안 표시 UI 구현\n7. 테스트: 보고서 및 통계 UI가 다양한 데이터 시나리오에서 올바르게 표시되는지 확인",
          "status": "pending",
          "parentTaskId": 9
        }
      ]
    },
    {
      "id": 10,
      "title": "[런칭] 홈 피드 및 프로필 페이지 개발",
      "description": "꿈 카드 피드와 기본 프로필 페이지 구현",
      "status": "pending",
      "dependencies": [
        2,
        4,
        5,
        9
      ],
      "priority": "lowest",
      "details": "모든 꿈을 카드로 보여주는 홈 피드 UI를 설계하고 구현합니다. 꿈 카드 클릭 시 해당 꿈의 목표만 볼 수 있는 상세 페이지로 이동하는 기능을 구현합니다. 꿈 카드에 마감일, 진행률 등 주요 정보를 표시합니다. 기본적인 프로필 페이지를 구현하여 계정명을 표시합니다. 꿈 필터링 및 정렬 옵션을 추가합니다.",
      "testStrategy": "홈 피드에서 꿈 카드가 올바르게 표시되는지 테스트합니다. 꿈 카드 클릭 시 상세 페이지로 정확히 이동하는지 확인합니다. 다양한 필터링 및 정렬 옵션이 올바르게 작동하는지 테스트합니다. 프로필 페이지에 계정명이 올바르게 표시되는지 검증합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "홈 피드 UI 설계 및 구현",
          "description": "모든 꿈을 카드로 보여주는 홈 피드 UI를 구현합니다.",
          "dependencies": [],
          "details": "1. 홈 피드 페이지 레이아웃 설계 및 구현\n2. 꿈 카드 컴포넌트 디자인 및 구현 (제목, 설명, 마감일, 진행률 표시)\n3. 꿈 데이터 조회 및 표시 로직 구현\n4. 무한 스크롤 또는 페이지네이션 구현\n5. 반응형 그리드 레이아웃 구현\n6. 테스트: 홈 피드가 다양한 꿈 데이터와 화면 크기에서 올바르게 표시되는지 확인\n\n<info added on 2025-05-03T07:43:06.518Z>\n## 구현 세부 사항\n\n### 1. 홈 피드 레이아웃 구현\n```tsx\n// src/pages/Dashboard.tsx\nimport { useEffect, useState } from 'react';\nimport DreamCard from '../components/dream/DreamCard';\nimport { fetchUserDreams } from '../services/supabase';\nimport { Dream } from '../types/dream';\n\nexport default function Dashboard() {\n  const [dreams, setDreams] = useState<Dream[]>([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    async function loadDreams() {\n      try {\n        const data = await fetchUserDreams();\n        setDreams(data);\n      } catch (error) {\n        console.error('Failed to load dreams:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    loadDreams();\n  }, []);\n  \n  return (\n    <div className=\"container mx-auto px-4 py-8 max-w-app\">\n      <h1 className=\"text-2xl font-bold mb-6\">내 꿈 목록</h1>\n      \n      {loading ? (\n        <div className=\"flex justify-center py-12\">\n          <LoadingSpinner />\n        </div>\n      ) : dreams.length === 0 ? (\n        <EmptyState message=\"아직 등록된 꿈이 없습니다.\" actionText=\"꿈 추가하기\" />\n      ) : (\n        <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {dreams.map(dream => (\n            <DreamCard key={dream.id} dream={dream} />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n### 2. 꿈 카드 컴포넌트 구현\n```tsx\n// src/components/dream/DreamCard.tsx\nimport { useNavigate } from 'react-router-dom';\nimport { Dream } from '../../types/dream';\nimport { formatDate } from '../../utils/dateUtils';\n\ninterface DreamCardProps {\n  dream: Dream;\n}\n\nexport default function DreamCard({ dream }: DreamCardProps) {\n  const navigate = useNavigate();\n  const progress = calculateProgress(dream); // 진행률 계산 함수\n  \n  return (\n    <div \n      className=\"bg-white dark:bg-gray-800 rounded-lg shadow-md hover:shadow-lg transition-shadow p-5 cursor-pointer\"\n      onClick={() => navigate(`/dreams/${dream.id}`)}\n    >\n      <h3 className=\"font-semibold text-lg mb-2 truncate\">{dream.title}</h3>\n      <p className=\"text-gray-600 dark:text-gray-300 text-sm mb-4 line-clamp-2\">{dream.description}</p>\n      \n      <div className=\"flex justify-between text-xs text-gray-500 dark:text-gray-400 mb-3\">\n        <span>마감일: {dream.deadline ? formatDate(dream.deadline) : '없음'}</span>\n      </div>\n      \n      <div className=\"w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5\">\n        <div \n          className=\"bg-blue-600 h-2.5 rounded-full\" \n          style={{ width: `${progress}%` }}\n        ></div>\n      </div>\n      <div className=\"text-right text-xs mt-1\">{progress}%</div>\n    </div>\n  );\n}\n\nfunction calculateProgress(dream: Dream): number {\n  // 목표 달성률 계산 로직\n  if (!dream.goals || dream.goals.length === 0) return 0;\n  \n  const completedGoals = dream.goals.filter(goal => goal.completed).length;\n  return Math.round((completedGoals / dream.goals.length) * 100);\n}\n```\n\n### 3. 데이터 페치 서비스\n```tsx\n// src/services/supabase.ts\nimport { supabase } from '../lib/supabaseClient';\nimport { Dream } from '../types/dream';\n\nexport async function fetchUserDreams(\n  page = 1, \n  limit = 12\n): Promise<Dream[]> {\n  const offset = (page - 1) * limit;\n  \n  const { data, error } = await supabase\n    .from('dreams')\n    .select(`\n      *,\n      goals:dream_goals(*)\n    `)\n    .order('created_at', { ascending: false })\n    .range(offset, offset + limit - 1);\n    \n  if (error) {\n    console.error('Error fetching dreams:', error);\n    throw error;\n  }\n  \n  return data || [];\n}\n```\n\n### 4. 무한 스크롤 구현\n```tsx\n// src/hooks/useInfiniteScroll.ts\nimport { useEffect, useState } from 'react';\n\nexport function useInfiniteScroll<T>(\n  fetchFunction: (page: number, limit: number) => Promise<T[]>,\n  limit = 12\n) {\n  const [items, setItems] = useState<T[]>([]);\n  const [page, setPage] = useState(1);\n  const [loading, setLoading] = useState(false);\n  const [hasMore, setHasMore] = useState(true);\n  \n  async function loadMore() {\n    if (loading || !hasMore) return;\n    \n    setLoading(true);\n    try {\n      const newItems = await fetchFunction(page, limit);\n      if (newItems.length < limit) {\n        setHasMore(false);\n      }\n      setItems(prev => [...prev, ...newItems]);\n      setPage(prev => prev + 1);\n    } catch (error) {\n      console.error('Failed to load more items:', error);\n    } finally {\n      setLoading(false);\n    }\n  }\n  \n  // 스크롤 감지 로직\n  useEffect(() => {\n    const handleScroll = () => {\n      if (\n        window.innerHeight + document.documentElement.scrollTop >= \n        document.documentElement.offsetHeight - 300 &&\n        !loading && \n        hasMore\n      ) {\n        loadMore();\n      }\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [loading, hasMore]);\n  \n  return { items, loading, hasMore, loadMore };\n}\n```\n\n### 5. 타입 정의\n```tsx\n// src/types/dream.ts\nexport interface Dream {\n  id: string;\n  title: string;\n  description: string;\n  deadline?: string; // ISO 날짜 문자열\n  created_at: string;\n  updated_at: string;\n  user_id: string;\n  goals: DreamGoal[];\n}\n\nexport interface DreamGoal {\n  id: string;\n  dream_id: string;\n  title: string;\n  completed: boolean;\n  created_at: string;\n  updated_at: string;\n}\n```\n\n### 테스트 고려사항\n- 다양한 길이의 제목/설명에 대한 UI 테스트\n- 목표가 없는 꿈의 진행률 표시 확인\n- 스켈레톤 로딩 상태 구현 고려\n- 데이터 없을 때 빈 상태 UI 확인\n- 다크모드/라이트모드 전환 시 UI 확인\n</info added on 2025-05-03T07:43:06.518Z>",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 2,
          "title": "꿈 상세 페이지 구현",
          "description": "꿈 카드 클릭 시 이동할 꿈 상세 페이지를 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 꿈 상세 페이지 레이아웃 설계 및 구현\n2. 꿈 정보 헤더 섹션 구현 (제목, 설명, 마감일, 진행률 등)\n3. 해당 꿈에 연결된 목표 목록 표시 구현\n4. 목표 필터링 및 정렬 옵션 구현\n5. 꿈 편집 및 삭제 기능 구현\n6. 새 목표 추가 기능 구현\n7. 테스트: 꿈 상세 페이지가 올바른 꿈 데이터와 연결된 목표를 표시하는지 확인",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 3,
          "title": "꿈 필터링 및 정렬 기능 구현",
          "description": "홈 피드에서 꿈을 필터링하고 정렬할 수 있는 기능을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 필터 컴포넌트 디자인 및 구현\n2. 마감일 기준 필터링 구현 (임박한 마감, 지난 마감 등)\n3. 진행률 기준 필터링 구현 (완료율 높음/낮음 등)\n4. 생성일/마감일/제목 기준 정렬 구현\n5. 필터 및 정렬 상태 관리 구현\n6. 테스트: 다양한 필터 및 정렬 옵션이 올바르게 작동하는지 확인",
          "status": "done",
          "parentTaskId": 10
        },
        {
          "id": 4,
          "title": "꿈 검색 기능 구현",
          "description": "홈 피드에서 꿈을 검색할 수 있는 기능을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. 검색 입력 컴포넌트 디자인 및 구현\n2. 실시간 검색 결과 표시 구현\n3. 검색 쿼리 처리 및 결과 필터링 로직 구현\n4. 검색 결과 없음 상태 처리\n5. 최근 검색어 저장 및 표시 기능 구현 (선택적)\n6. 테스트: 다양한 검색 쿼리에 대해 올바른 결과가 표시되는지 확인",
          "status": "pending",
          "parentTaskId": 10
        },
        {
          "id": 5,
          "title": "프로필 페이지 구현",
          "description": "사용자 계정명을 표시하는 기본 프로필 페이지를 구현합니다.",
          "dependencies": [],
          "details": "1. 프로필 페이지 레이아웃 설계 및 구현\n2. 사용자 계정명 표시 구현\n3. 프로필 편집 기능 구현 (계정명 변경)\n4. 로그아웃 기능 구현\n5. 계정 설정 옵션 구현 (비밀번호 변경 등)\n6. 테스트: 프로필 페이지가 올바른 사용자 정보를 표시하고 편집 기능이 작동하는지 확인",
          "status": "pending",
          "parentTaskId": 10
        },
        {
          "id": 6,
          "title": "탭 네비게이션 구현",
          "description": "홈, 꿈, 목표, 프로필 탭 간의 네비게이션을 구현합니다.",
          "dependencies": [
            1,
            5
          ],
          "details": "1. 하단 탭 네비게이션 바 디자인 및 구현\n2. 탭 전환 애니메이션 구현\n3. 활성 탭 표시 구현\n4. 탭별 라우팅 설정\n5. 모바일/데스크톱 반응형 네비게이션 구현\n6. 테스트: 탭 네비게이션이 올바르게 작동하고 현재 활성 탭이 표시되는지 확인",
          "status": "pending",
          "parentTaskId": 10
        }
      ]
    }
  ],
  "metadata": {
    "projectName": "DreamCatcher Implementation",
    "totalTasks": 10,
    "sourceFile": "/Users/mac/Documents/DreamCatcher/scripts/prd.txt",
    "generatedAt": "2023-11-09"
  }
}